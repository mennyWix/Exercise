#include <iostream>#include <stdio.h>#include <string.h>class Node {public:    explicit Node(int val) : _val(val) {}    int _val;    Node* next = nullptr;    Node* prev = nullptr;};class SinglyLinkedList {public:    void add(int val) {        if (!head) {            //First node            head = new Node(val);        } else {            Node* newNode = new Node(val);            newNode->next = head;            head = newNode;        }     }         void print(void) const {       Node* node = head;        while(node) {            std::cout << "val= " << node->_val << std::endl;            node = node->next;        }     }        Node* find(int val) {        Node* node = head;        while(node) {            if (node->_val == val) {                return node;            }            node = node->next;        }        return nullptr;    }        void removeWithoutKnowingHead(int val) {        Node* node = find(val);        Node* nextNode = node->next;        if (nextNode) {            node->_val = nextNode->_val;                        //Now remove nextNode...            node->next = nextNode->next;            delete nextNode;        } else {            std::cout << "Cannot delete last node when head is not available!!!" << std::endl;        }    }private:    Node* head = nullptr;};class LinkedList {public:    void add(int val) {        if (!head) {            //First node            tail = head = new Node(val);        } else {            Node* newNode = new Node(val);            newNode->next = head;            head->prev = newNode;            head = newNode;        }    }        void remove(Node* node) {        if (!node) {            return;        }        if (node == head) {            if (!node->next) { //Same as if node == tail...                //only item in the list                delete node;                head = tail = nullptr;                return;            }            head->next->prev = nullptr;            head = head->next;            delete node;        } else if (node == tail) {            //No need to check if this is the only item since it has been checked before...            tail->prev->next = nullptr;            tail = tail->prev;            delete node;        } else {            node->prev->next = node->next;            node->next->prev = node->prev;            delete node;        }    }        void remove(int val) {        remove(find(val, head));    }        void print() const {        Node* node = head;        while(node) {            std::cout << "val= " << node->_val << std::endl;            node = node->next;        }    }        void reverse() const {        Node* node = tail;        while(node) {            std::cout << "val= " << node->_val << std::endl;            node = node->prev;        }    }        //Remove all duplicates with no extra memory.    //Note that the alternative solution with extra space will be    //hashing values while iterating. If found, remove. If not, insert to hash    Node* removeDuplicates(void) {        Node* node = head;        while(node) {            Node* duplicatedNode = find(node->_val, node->next);            while(duplicatedNode) {                remove(duplicatedNode);                duplicatedNode = find(node->_val, node->next);            }            node = node->next;        }    }        void findKthFromLast(int k) const {        Node* node = nullptr;        recursiveKthFromLast(head, k, node);        if (node) {            std::cout << "the " << k << "th element from the end: " << node->_val << std::endl;        }    }        Node* findKthFromTheLastIterative(int k) const {        Node* firstNode = head;        Node* secondNode = head;        for (int i=0; i<k; ++i) {            if (secondNode) {                secondNode = secondNode->next;            } else {                return nullptr;            }        }        while(secondNode->next) {            firstNode = firstNode->next;            secondNode = secondNode->next;        }        return firstNode;    }    private:    int recursiveKthFromLast(Node* currNode, int k, Node*& kthNode) const {        if (!currNode) {            return -1;        }        int level = 1 + recursiveKthFromLast(currNode->next, k, kthNode);        if (level == k) {            kthNode = currNode;            return k+1; //Some return value to make sure that the condition will not be true again...        }        return level;    }        Node* find(int val, Node* nodeBegin) {        Node* node = nodeBegin;        while(node) {            if (node->_val == val) {                return node;            }            node = node->next;        }        return nullptr;    }        Node* head = nullptr;    Node* tail = nullptr;};int main() {    SinglyLinkedList list;    list.add(1);    list.add(40);    list.add(23);    list.add(100);    list.add(230);    list.add(76);    list.add(10);    // list.removeDuplicates();    // list.findKthFromLast(20);    // Node* node = list.findKthFromTheLastIterative(1);    list.removeWithoutKnowingHead(1);    list.print();    }     